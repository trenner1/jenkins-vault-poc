pipeline {
  agent any

  options {
    ansiColor('xterm')
    timestamps()
  }

  parameters {
    booleanParam(name: 'VERBOSE', defaultValue: false, description: 'Print detailed debug logs')
  }

  environment {
    VAULT_ADDR = 'http://vault:8200'
  }

  stages {

    stage('Resolve user & groups') {
      steps {
        script {
          def cause   = currentBuild.getBuildCauses('hudson.model.Cause$UserIdCause')
          def starter = cause ? cause[0]?.userId : null
          if (!starter) { error 'Cannot determine triggering user (launch from UI)' }

          def u = hudson.model.User.getById(starter, false)
          if (!u) { error "Unknown Jenkins user: ${starter}" }

          def groups = u.impersonate().authorities.collect { it.authority }.findAll { it }
          def allowed  = ['mobile-developers','frontend-developers','backend-developers','devops-team']
          def eligible = groups.intersect(allowed)
          if (eligible.isEmpty()) { error "No eligible groups. Yours: ${groups}" }

          env.BUILD_USER_EMAIL   = starter
          env.ELIGIBLE_GROUPS_NL = eligible.join('\n')

          echo "user: ${starter}"
          echo "eligible groups: ${eligible}"
          if (params.VERBOSE) { echo "all groups: ${groups}" }
        }
      }
    }

    stage('Choose role') {
      steps {
        script {
          def eligible = env.ELIGIBLE_GROUPS_NL.readLines().findAll { it?.trim() }
          def chosen = eligible.size() == 1 ? eligible[0] : input(
            id: 'chooseRole',
            message: 'Choose group to use for Vault',
            parameters: [choice(name: 'GROUP', choices: env.ELIGIBLE_GROUPS_NL)]
          ) as String

          env.SELECTED_GROUP = chosen
          env.VAULT_ROLE     = chosen  // Use Okta group name directly
          echo "role: ${env.VAULT_ROLE}"
        }
      }
    }

    stage('Login to Vault & mint child token') {
      steps {
        withCredentials([file(credentialsId: 'jenkins-oidc-privkey', variable: 'JWT_KEY')]) {
          sh(label: 'Create JWT & login', script: '''
set -eu

b64(){ openssl base64 -A | tr "+/" "-_" | tr -d "="; }

# JWT header
printf '{"alg":"RS256","typ":"JWT","kid":"jenkins-dev-key-1"}' > /tmp/h.json
H=$(b64 < /tmp/h.json)

# JWT payload
IAT=$(date +%s); EXP=$((IAT+900))
JOB="${JOB_NAME:-}"; BID="${BUILD_ID:-}"
GROUPS_SPACE=$(printf %s "$ELIGIBLE_GROUPS_NL" | tr '\\n' ' ')
jq -n \
  --arg iss "http://localhost:8080" \
  --arg sub "jenkins-dev" \
  --arg aud "vault" \
  --arg env "dev" \
  --arg job "$JOB" \
  --arg build "$BID" \
  --arg user_id "${BUILD_USER_EMAIL:-unknown}" \
  --arg selected_group "${SELECTED_GROUP}" \
  --arg groups_str "$GROUPS_SPACE" \
  --argjson iat "$IAT" --argjson exp "$EXP" \
  '{
     iss:$iss, sub:$sub, aud:$aud, iat:$iat, exp:$exp, env:$env,
     jenkins_job:$job, build_id:$build,
     user_id:$user_id, selected_group:$selected_group,
     okta_groups: ($groups_str | split(" ") | map(select(length>0)))
   }' > /tmp/p.json

P=$(b64 < /tmp/p.json)
SIG=$(printf "%s.%s" "$H" "$P" | openssl dgst -sha256 -sign "$JWT_KEY" -binary | b64)
ID_TOKEN="$H.$P.$SIG"

# Vault login
LOGIN=$(curl -sS -X POST "$VAULT_ADDR/v1/auth/jenkins-jwt/login" \
  -H 'Content-Type: application/json' \
  -d '{"role":"'"${VAULT_ROLE}"'","jwt":"'"$ID_TOKEN"'"}')

VAULT_TOKEN=$(printf %s "$LOGIN" | jq -r .auth.client_token)
[ -n "${VAULT_TOKEN:-}" ] && [ "${VAULT_TOKEN}" != "null" ] || { echo "Vault login failed"; echo "$LOGIN" | jq .; exit 1; }

# Child token
REQ=$(jq -n \
  --arg role "${VAULT_ROLE}" \
  --arg job "$JOB" \
  --arg build "$BID" \
  --arg user_id "${BUILD_USER_EMAIL:-unknown}" \
  --arg selected "${SELECTED_GROUP}" \
  '{
    ttl:"15m", num_uses:10, policies:[$role],
    meta:{ job:$job, build_id:$build, user_id:$user_id, role:$role, selected_group:$selected }
  }')

RESP=$(printf "%s" "$REQ" | curl -sS -H "X-Vault-Token: $VAULT_TOKEN" \
  -X POST "$VAULT_ADDR/v1/auth/token/create/jenkins-child" -d @-)

CHILD=$(printf %s "$RESP" | jq -r '.auth.client_token')
[ -n "${CHILD:-}" ] && [ "${CHILD}" != "null" ] || { echo "child token create failed"; echo "$RESP" | jq .; exit 1; }

printf "VAULT_TOKEN=%s\\n" "$CHILD" > .vault_token

[ "${VERBOSE:-false}" = "true" ] && { echo "login summary:"; echo "$LOGIN" | jq '{policies:.auth.policies,lease:.auth.lease_duration,meta:.auth.metadata}'; } || true
''')
        }
      }
    }

    stage('Read team secret') {
      steps {
        sh(label: 'Read kv secret', script: '''
set -eu
. ./.vault_token

# map group â†’ project
case "${SELECTED_GROUP}" in
  mobile-developers)   PROJECT="mobile-app" ;;
  frontend-developers) PROJECT="frontend-app" ;;
  backend-developers)  PROJECT="backend-service" ;;
  devops-team)         PROJECT="devops-tools" ;;
  *) echo "unknown group ${SELECTED_GROUP}" >&2; exit 1 ;;
esac

echo "Reading secret for team: ${SELECTED_GROUP}"
echo "Secret path: kv/data/dev/apps/${PROJECT}/example"
echo "=================================================="

RESP=$(curl -sS -H "X-Vault-Token: $VAULT_TOKEN" \
  "$VAULT_ADDR/v1/kv/data/dev/apps/${PROJECT}/example")

# Dash-safe: pipe JSON into jq; avoid jq interpolation syntax that confuses Groovy
if echo "$RESP" | jq -e '.data.data' >/dev/null 2>&1; then
  echo "Successfully retrieved secret:"
  echo "Secret contents:"
  echo "$RESP" | jq -r '.data.data | to_entries[] | "  " + .key + ": " + (.value | tostring)'
  echo "=================================================="
  echo "Proof: ${SELECTED_GROUP} team has access to ${PROJECT} secrets!"
else
  echo "Failed to read secret for ${PROJECT}"
  echo "$RESP" | jq .
  exit 1
fi
''')
      }
    }

    stage('Boundary check') {
      steps {
        sh(label: 'Deny other project', script: '''
set -eu
. ./.vault_token

case "${SELECTED_GROUP}" in
  mobile-developers)   ALLOWED="mobile-app" ;;
  frontend-developers) ALLOWED="frontend-app" ;;
  backend-developers)  ALLOWED="backend-service" ;;
  devops-team)         ALLOWED="devops-tools" ;;
esac

ALL="mobile-app frontend-app backend-service devops-tools"
FORB=""
for p in $ALL; do [ "$p" = "$ALLOWED" ] || FORB="$FORB $p"; done
set -- $FORB
TEST_PROJECT="$1"

CODE=$(curl -sS -o /tmp/deny.json -w "%{http_code}" \
  -H "X-Vault-Token: $VAULT_TOKEN" \
  "$VAULT_ADDR/v1/kv/data/dev/apps/$TEST_PROJECT/example" || true)

if [ "$CODE" = "403" ] || [ "$CODE" = "404" ]; then
  echo "deny OK for $TEST_PROJECT (HTTP $CODE)"
else
  echo "unexpected access result for $TEST_PROJECT (HTTP $CODE)"
  [ "${VERBOSE:-false}" = "true" ] && jq . /tmp/deny.json || true
  exit 1
fi
''')
      }
    }

    stage('Summary') {
      steps {
        sh(label: 'compact summary', script: '''
set -eu
. ./.vault_token
LOOKUP=$(curl -sS -X POST -H "X-Vault-Token: $VAULT_TOKEN" "$VAULT_ADDR/v1/auth/token/lookup-self")
jq -n --arg role "${VAULT_ROLE}" --arg group "${SELECTED_GROUP}" \
      --arg user "${BUILD_USER_EMAIL}" --arg job "${JOB_NAME}" \
      --arg ttl "$(echo "$LOOKUP" | jq -r .data.ttl)" \
      --arg policies "$(echo "$LOOKUP" | jq -cr .data.policies)" \
      '{role:$role, group:$group, user:$user, job:$job, ttl_s:($ttl|tonumber), policies:($policies|fromjson)}'
''')
      }
    }
  }

  post {
    always {
      sh(label: 'Revoke token', script: '''
if [ -f ./.vault_token ]; then
  . ./.vault_token
  curl -sS -X POST -H "X-Vault-Token: $VAULT_TOKEN" "$VAULT_ADDR/v1/auth/token/revoke-self" >/dev/null || true
fi
rm -f .vault_token || true
''')
    }
  }
}
