pipeline {
  agent any
  
  parameters {
    choice(
      name: 'VAULT_ROLE',
      choices: ['readonly-builds', 'developer-builds', 'admin-builds'],
      description: 'Select the Vault role for this build (readonly=read secrets only, developer=read/write job secrets, admin=full access)'
    )
    choice(
      name: 'ENVIRONMENT',
      choices: ['dev', 'staging', 'prod'],
      description: 'Target environment for this pipeline run'
    )
    choice(
      name: 'PROJECT_NAME',
      choices: ['mobile-app', 'frontend-app', 'backend-service', 'devops-tools'],
      description: 'Team project for scoped secret access'
    )
  }
  
  environment {
    // Jenkins â†’ Vault inside your compose network
    VAULT_ADDR = 'http://vault:8200'
  }

  stages {
    stage('Show Selected Parameters') {
      steps {
        script {
          echo "ðŸ” Selected Vault Role: ${params.VAULT_ROLE}"
          echo "ðŸŽ¯ Target Environment: ${params.ENVIRONMENT}"
          echo "ðŸ“ Project Name: ${params.PROJECT_NAME}"
          echo "ðŸ‘¤ Triggered by: ${currentBuild.getBuildCauses('hudson.model.Cause$UserIdCause')[0]?.userId ?: 'system'}"
        }
      }
    }

    stage('JWT â†’ Vault login & child token') {
      steps {
        withCredentials([file(credentialsId: 'jenkins-oidc-privkey', variable: 'JWT_KEY')]) {
          sh '''
            set -eu

            b64url() { openssl base64 -A | tr "+/" "-_" | tr -d "="; }

            # --- Build JWT header
            printf '{"alg":"RS256","typ":"JWT","kid":"jenkins-dev-key-1"}' > /tmp/h.json
            H=$(b64url < /tmp/h.json)

            # --- Build JWT payload (claims must match Vault role bindings)
            IAT=$(date +%s); EXP=$((IAT+900))
            JOB="${JOB_NAME:-}"; REPO="${GIT_URL:-}"; BR="${BRANCH_NAME:-}"
            BID="${BUILD_ID:-}"; COM="${GIT_COMMIT:-}"

            jq -n \
              --arg iss "http://localhost:8080" \
              --arg sub "jenkins-dev" \
              --arg aud "vault" \
              --arg env "${ENVIRONMENT}" \
              --arg role "${VAULT_ROLE}" \
              --arg job "$JOB" \
              --arg repo "$REPO" \
              --arg branch "$BR" \
              --arg build "$BID" \
              --arg commit "$COM" \
              --arg project "${PROJECT_NAME}" \
              --argjson iat "$IAT" \
              --argjson exp "$EXP" \
              '{iss:$iss,sub:$sub,aud:$aud,iat:$iat,exp:$exp,env:$env,role:$role,
                jenkins_job:$job,repo:$repo,branch:$branch,build_id:$build,commit:$commit,project:$project}' > /tmp/p.json
            P=$(b64url < /tmp/p.json)

            # --- Sign JWT with private key stored in Jenkins credentials
            SIG=$(printf "%s.%s" "$H" "$P" | openssl dgst -sha256 -sign "$JWT_KEY" -binary | b64url)
            ID_TOKEN="$H.$P.$SIG"

            # --- Login to Vault via JWT auth using selected role
            LOGIN_RESP=$(curl -s -X POST "$VAULT_ADDR/v1/auth/jenkins-jwt/login" \
              -H 'Content-Type: application/json' \
              -d '{"role":"'"${VAULT_ROLE}"'","jwt":"'"$ID_TOKEN"'"}')
            VAULT_TOKEN=$(echo "$LOGIN_RESP" | jq -r .auth.client_token)
            [ "$VAULT_TOKEN" != "null" ] && [ -n "$VAULT_TOKEN" ] || { echo "Vault login failed"; echo "$LOGIN_RESP" | jq .; exit 1; }

            # --- Create a short-lived child token with rich meta
            # Determine policy based on selected role
            case "${VAULT_ROLE}" in
              "admin-builds")
                POLICY="jenkins-admin"
                ;;
              "developer-builds")
                POLICY="jenkins-developers"
                ;;
              "readonly-builds")
                POLICY="jenkins-readonly"
                ;;
              *)
                echo "Unknown role: ${VAULT_ROLE}"; exit 1
                ;;
            esac

            REQ=$(jq -n \
              --arg job "$JOB" \
              --arg bid "$BID" \
              --arg repo "$REPO" \
              --arg branch "$BR" \
              --arg commit "$COM" \
              --arg env "${ENVIRONMENT}" \
              --arg role "${VAULT_ROLE}" \
              --arg project "${PROJECT_NAME}" \
              --arg policy "$POLICY" \
              '{
                ttl: "15m",
                num_uses: 10,
                policies: [$policy],
                meta: {
                  job: $job,
                  build_id: $bid,
                  repo: $repo,
                  branch: $branch,
                  commit: $commit,
                  env: $env,
                  role: $role,
                  project: $project,
                  signing_kid: "jenkins-dev-key-1"
                }
              }')

            RESP=$(printf "%s" "$REQ" | curl -s \
              -H "X-Vault-Token: $VAULT_TOKEN" \
              -X POST "$VAULT_ADDR/v1/auth/token/create/jenkins-child" \
              -d @-)

            CHILD=$(echo "$RESP" | jq -r '.auth.client_token')
            [ "$CHILD" != "null" ] && [ -n "$CHILD" ] || { echo "child token create failed"; echo "$RESP" | jq .; exit 1; }

            printf "VAULT_TOKEN=%s\n" "$CHILD" > .vault_token
            echo "âœ… Successfully created child token with policy: $POLICY"
          '''
        }
      }
    }
    
    stage('Read secret (role-based access)') {
      steps {
        sh '''
          set -eu
          . ./.vault_token
          
          echo "ðŸ”‘ Reading kv/${ENVIRONMENT}/apps/${PROJECT_NAME}/example (v2 data endpoint)"
          echo "ðŸ“‹ Using role: ${VAULT_ROLE} with corresponding policy"
          
          RESP=$(curl -s -H "X-Vault-Token: $VAULT_TOKEN" \
            "$VAULT_ADDR/v1/kv/data/${ENVIRONMENT}/apps/${PROJECT_NAME}/example")
          
          if echo "$RESP" | jq -e '.data.data' > /dev/null 2>&1; then
            echo "âœ… Successfully read secret:"
            echo "$RESP" | jq '.data.data'
          else
            echo "âŒ Failed to read secret:"
            echo "$RESP" | jq .
          fi
        '''
      }
    }

    stage('Test cross-project access (expect different behavior by role)') {
      steps {
        sh '''
          set -eu
          . ./.vault_token
          OTHER_PROJECT="frontend-app"
          
          echo "ðŸ§ª Testing access to different project: $OTHER_PROJECT"
          echo "ðŸ” Current role: ${VAULT_ROLE}"
          
          CODE=$(curl -s -o /tmp/resp.json -w "%{http_code}" \
            -H "X-Vault-Token: $VAULT_TOKEN" \
            "$VAULT_ADDR/v1/kv/data/${ENVIRONMENT}/apps/$OTHER_PROJECT/example")
          
          echo "HTTP Response Code: $CODE"
          
          case "${VAULT_ROLE}" in
            "admin-builds")
              echo "ðŸ”“ Admin role - should have access to other projects"
              ;;
            "developer-builds"|"readonly-builds")
              echo "ðŸ”’ Non-admin role - access should be restricted to own project scope"
              ;;
          esac
          
          cat /tmp/resp.json; echo
        '''
      }
    }

    stage('Capture Vault token proof') {
      steps {
        sh '''
          set -eu
          . ./.vault_token
    
          # Lookup self to get accessor/meta
          SELF=$(curl -s -X POST -H "X-Vault-Token: $VAULT_TOKEN" \
            "$VAULT_ADDR/v1/auth/token/lookup-self")
    
          ACCESSOR=$(echo "$SELF" | jq -r '.data.accessor')
          TTL=$(echo "$SELF"       | jq -r '.data.ttl')
          ISSUE=$(echo "$SELF"     | jq -r '.data.issue_time')
          META=$(echo "$SELF"      | jq -c '.data.meta')
          POLICIES=$(echo "$SELF"  | jq -c '.data.policies')
    
          # Create a non-sensitive fingerprint of the token
          FPR_SHA256=$(printf %s "$VAULT_TOKEN" | openssl dgst -sha256 | sed 's/^.*= //')
    
          cat > vault-token-proof.json <<EOF
          {
            "selected_role": "${VAULT_ROLE}",
            "target_environment": "${ENVIRONMENT}",
            "project_name": "${PROJECT_NAME}", 
            "accessor": "$ACCESSOR",
            "token_fingerprint_sha256": "$FPR_SHA256",
            "ttl_seconds": $TTL,
            "issue_time": "$ISSUE",
            "policies": $POLICIES,
            "meta": $META
          }
          EOF
    
          echo "ðŸ“„ Token information captured:"
          jq . vault-token-proof.json
        '''
        archiveArtifacts artifacts: 'vault-token-proof.json', onlyIfSuccessful: false
      }
    }

    stage('Show final token details') {
      steps {
        sh '''
          set -eu
          . ./.vault_token
          
          echo "ðŸ” Final token analysis:"
          RESP=$(curl -s -X POST -H "X-Vault-Token: $VAULT_TOKEN" \
            "$VAULT_ADDR/v1/auth/token/lookup-self")
          
          echo "Selected Role: ${VAULT_ROLE}"
          echo "TTL Remaining: $(echo "$RESP" | jq -r '.data.ttl') seconds"
          echo "Policies: $(echo "$RESP" | jq -c '.data.policies')"
          echo "Token Metadata:"
          echo "$RESP" | jq '.data.meta'
        '''
      }
    }
  }

  post {
    always { 
      sh '''
        if [ -f ./.vault_token ]; then
          . ./.vault_token
          echo "ðŸ§¹ Revoking Vault token..."
          curl -s -X POST -H "X-Vault-Token: $VAULT_TOKEN" \
            "$VAULT_ADDR/v1/auth/token/revoke-self" || true
        fi
        rm -f .vault_token || true
      ''' 
    }
  }
}